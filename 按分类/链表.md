# 链表

## Easy

#### [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

设置一个存放结果的链表，链表头为dummy，还有一个为dummy赋值服务的指针p，初始时指向头节点。

为两个有序链表设置指针p1、p2，用于遍历list1和list2。

当p1和p2指向的值都不为空时，进行大小比较，把小的放入dummy，也就是p指针指向的位置。

赋值后，要进行两步操作：

1、小的所指向的位置要前进一步，好和另一条链表的值再比较；

2、结果链表的指针当前值已经赋值了，所以它也要前进一步。

当两条链表的指针指向了null值，则意味着两条链表有遍历完的情况，

则这时哪条链表还有值的话，就追加到结果链表，如果都到null了，则直接返回结果链表。

此时注意返回的结果链表不包含哑节点。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        // 设置一个哑节点作为结果链表的起始->p。
        ListNode dummy = new ListNode(-1),p = dummy;
        // 为两条链表分别设置两个指针->p1/p2
        ListNode p1 = list1,p2 = list2;

        // 当两个指针指向的位置都有值时，比较两指针对应的值
        while(p1!=null&&p2!=null){
            // p1值大于p2值
            if(p1.val>p2.val){
                // 则p2要加入结果链表
                p.next = p2;
                // 然后p2的指针指向它所在链表的下一个位置
                p2 = p2.next;
            }else{
                //p1值小于p2值，则p1要加入结果链表
                p.next = p1;
                // 然后p1的指针指向它所在链表的下一个位置
                p1 = p1.next;
            }
            // 赋值后结果列表指针进1
            p = p.next;
        }

        // 当两条链表有一条为null时，跳出while循环，
        // 这时观察是哪一条链表不为null，则接上结果链表
        if(p1!=null){
            p.next = p1;
        }
        if(p2!=null){
            p.next = p2;
        }
    	// 理解为什么这里是dummy.next，
    	// dummy结果是[-1,1,1,2,3,4,4]
    	// dummy.next结果是[1,1,2,3,4,4]
    	// p结果是[4,4]
    	return dummy.next;
    }
}
```

#### [83. 删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)

创建一个指针p作为遍历链表的指针，

如果当前指针的下一位不为null，比较当前指针值与链表下一位指针的值，

如果相等，说明出现重复元素，那么就跳过这个“下一位指针”，让p.next指向下下个位置。

如果不等，说明当前指针值与下一位不重复，则p.next可以指向这个下一位。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if(head==null){
            return head;
        }
        ListNode p = head;
        while(p.next!=null){
            if(p.val==p.next.val){
                p.next = p.next.next;
            }else{
                p = p.next;
            }
        }
        return head;
    }
}
```

#### [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

1. 哈希表

   利用哈希表存储链表的每个节点，如果出现重复的节点，则说明是环形链表。

   ```java
   /**
    * Definition for singly-linked list.
    * class ListNode {
    *     int val;
    *     ListNode next;
    *     ListNode(int x) {
    *         val = x;
    *         next = null;
    *     }
    * }
    */
   public class Solution {
       public boolean hasCycle(ListNode head) {
           Set<ListNode> s = new HashSet<>();
           while(head!=null){
               if(!s.add(head)){
                   return true;
               }
               head = head.next;
           }
           return false;
       }
   }
   ```

2. 快慢指针

   利用快慢指针的解法，参考 *Floyd 判圈算法*，快指针每次走2步，慢指针每次走1步，

   如果非环形链表，快指针最终会遇到null，则证明不是环形链表。

   如果是环形链表，根据 *Floyd 判圈算法*，最终会出现快慢指针相遇的情况。

   ```java
   /**
    * Definition for singly-linked list.
    * class ListNode {
    *     int val;
    *     ListNode next;
    *     ListNode(int x) {
    *         val = x;
    *         next = null;
    *     }
    * }
    */
   public class Solution {
       public boolean hasCycle(ListNode head) {
           ListNode slow,fast;
           slow = fast = head;
           // 问：为什么这里的循环条件是：fast!=null&&fast.next!=null
           // 答：如果fast==null，则已说明不是环形链表；如果
           while(fast!=null&&fast.next!=null){
               fast = fast.next.next;
               slow = slow.next;
               if(fast==slow){
                   return true;
               }
           }
           return false;
       }
   }
   ```

#### [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

1. 哈希集合法

   创建一个哈希集合s，遍历链表A，将每个节点放入集合，

   再遍历链表B，如果有碰撞的，则说明有相交节点。

   ```java
   /**
    * Definition for singly-linked list.
    * public class ListNode {
    *     int val;
    *     ListNode next;
    *     ListNode(int x) {
    *         val = x;
    *         next = null;
    *     }
    * }
    */
   public class Solution {
       public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
           Set<ListNode> s = new HashSet<>();
           // 创建一个用于遍历的头指针
           ListNode temp = headA;
           while(temp!=null){
               s.add(temp);
               temp = temp.next;
           }
           temp = headB;
           while(temp!=null){
               if(s.contains(temp)){
                   return temp;
               }
               temp = temp.next;
           }
           return temp;
   
       }
   }
   ```

2. 双指针法

   为两条链表创建两个指针pa、pb，两条链表都从头节点出发，**同时**向后遍历，步长为1；

   遍历链表A，当pa指针所处为null时，开始遍历链表B；

   遍历链表B，当pb指针所处为null时，开始遍历链表A；

   假设链表A长度为a，链表B长度为b，相同节点C到尾部长度为c，如果不存在相交节点，则c=0。

   则链表A头节点到C长度为a-c，同理，链表B头节点到C长度为b-c；

   那么从A头节点第二次到C，经过长度为a+(b-c)，从B头节点第二次到C，经过长度为b+(a-c)。

   而`a+(b-c)=b+(a-c)`，距离一致，所以如果有相交节点，都从头节点出发，那双方就会相遇在C点。

   ```java
   /**
    * Definition for singly-linked list.
    * public class ListNode {
    *     int val;
    *     ListNode next;
    *     ListNode(int x) {
    *         val = x;
    *         next = null;
    *     }
    * }
    */
   public class Solution {
       public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
           ListNode a = headA,b = headB;
           while(a!=b){
               a = a==null?headB:a.next;
               b = b==null?headA:b.next;
           }
           return a;
       }
   }
   ```

#### [203. 移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/)

```java

```

#### [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

```java

```

#### [234. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/)

```java
```

#### [237. 删除链表中的节点](https://leetcode-cn.com/problems/delete-node-in-a-linked-list/)

```java

```

#### [705. 设计哈希集合](https://leetcode-cn.com/problems/design-hashset/)

```java
```

#### [706. 设计哈希映射](https://leetcode-cn.com/problems/design-hashmap/)

```java

```

#### [716. 最大栈](https://leetcode-cn.com/problems/max-stack/)

```java

```

#### [876. 链表的中间结点](https://leetcode-cn.com/problems/middle-of-the-linked-list/)

快慢指针做法，慢指针走一步，快指针走一步，

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode middleNode(ListNode head) {
        ListNode slow = head,fast = head;
        while(fast!=null&&fast.next!=null){
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }
}
```

#### [1290. 二进制链表转整数](https://leetcode-cn.com/problems/convert-binary-number-in-a-linked-list-to-integer/)

```java
```

#### [1474. 删除链表 M 个节点之后的 N 个节点](https://leetcode-cn.com/problems/delete-n-nodes-after-m-nodes-of-a-linked-list/)

```java

```

## Medium

#### [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

```java

```

#### [19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

创建一个返回链表倒数第 k 个节点的函数findNode，

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(-1);
        dummy.next = head;
        ListNode x = findNode(dummy, n + 1);
        x.next = x.next.next;
        return dummy.next;
    }

    public ListNode findNode(ListNode head,int n){
        ListNode fast = head;
        while(n--!=0){
            fast = fast.next;
        }
        ListNode slow = head;
        while(fast!=null){
            slow = slow.next;
            fast = fast.next;
        }
        return slow;
    }
}
```

#### [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

```java
```

#### [61. 旋转链表](https://leetcode-cn.com/problems/rotate-list/)

```java
```

#### [82. 删除排序链表中的重复元素 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/)

```java
```

#### [86. 分隔链表](https://leetcode-cn.com/problems/partition-list/)

```java
```

#### [92. 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)

```java
```

#### [109. 有序链表转换二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/)

```java
```

#### [114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)

```java
```

#### [138. 复制带随机指针的链表](https://leetcode-cn.com/problems/copy-list-with-random-pointer/)

```java

```

#### [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

```java
```

#### [143. 重排链表](https://leetcode-cn.com/problems/reorder-list/)

```java
```

#### [146. LRU 缓存机制](https://leetcode-cn.com/problems/lru-cache/)

```java
```

#### [147. 对链表进行插入排序](https://leetcode-cn.com/problems/insertion-sort-list/)

```java
```

#### [148. 排序链表](https://leetcode-cn.com/problems/sort-list/)

```java
```

#### [328. 奇偶链表](https://leetcode-cn.com/problems/odd-even-linked-list/)

```java
```

#### [355. 设计推特](https://leetcode-cn.com/problems/design-twitter/)

```java
```

#### [369. 给单链表加一](https://leetcode-cn.com/problems/plus-one-linked-list/)

#### [379. 电话目录管理系统](https://leetcode-cn.com/problems/design-phone-directory/)

#### [382. 链表随机节点](https://leetcode-cn.com/problems/linked-list-random-node/)

#### [426. 将二叉搜索树转化为排序的双向链表](https://leetcode-cn.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/)

#### [430. 扁平化多级双向链表](https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list/)

#### [445. 两数相加 II](https://leetcode-cn.com/problems/add-two-numbers-ii/)

#### [622. 设计循环队列](https://leetcode-cn.com/problems/design-circular-queue/)



## Hard

#### [23. 合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

```java

```

#### [25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)

```java

```

#### [432. 全 O(1) 的数据结构](https://leetcode-cn.com/problems/all-oone-data-structure/)

```java

```

#### [460. LFU 缓存](https://leetcode-cn.com/problems/lfu-cache/)

```java
```

#### [1206. 设计跳表](https://leetcode-cn.com/problems/design-skiplist/)

```java

```

